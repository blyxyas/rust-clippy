name: Clippy changelog check

on:
  merge_group:
  pull_request:
    types: [opened, reopened, synchronize, edited]

concurrency:
  # For a given workflow, if we push to the same PR, cancel all previous builds on that PR.
  # If the push is not attached to a PR, we will cancel all builds on the same branch.
  group: "${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}"
  cancel-in-progress: true

jobs:

  changelog:
    runs-on: ubuntu-latest

    steps:
    # Run
    - name: Check Changelog
      if: ${{ github.event_name == 'pull_request' }}
      run: |
        if [[ -z $(grep -oP 'changelog: *\K\S+' <<< "$PR_BODY") ]]; then
          echo "::error::Pull request message must contain 'changelog: ...' with your changelog. Please add it."
          exit 1
        else
          echo "changelog: $output"
          if [[ "${output}" == \[\`* ]]; then
            echo "LINT_CHANGELOG=\"${output//[$'\t\r\n ']}\"" >> $GITHUB_ENV
          else
            echo "LINT_CHANGELOG=\"\"" >> $GITHUB_ENV
          fi
        fi
      env:
        PYTHONIOENCODING: 'utf-8'
    - name: New Lint Label
      if: ${{ steps.get-changed-files.output.files }}
      run: |
            PR_NUMBER=${{ github.event.pull_request.number }}
            COMMENT="Demo comment"
            GITHUB_TOKEN=${{ secrest.GITHUB_TOKEN }}
            COMMENT_URL="https://api.github.com/repos/${{ github.repository }}/issues/${PR_NUMBER}/comments"

          curl -s -H "Authorization: token ${GITHUB_TOKEN}" -X POST $COMMENT_URL -d "{\"body\":\"$COMMENT\"}"
            # if (${{ env.LINT_CHANGELOG }} != "") {
            # const { data: names } =  await github.rest.issues.listLabelsOnIssue({
              # owner: ${{ github.repository_owner }},
              # repo: 'rust-clippy',
              # issue_number: ${{ github.event.number }}
            # });

            # if (!(names.filter(function(e) {; return e.name === "A-new-lint"; }).filter > 0)) {
              # const lint_name = /\[`(.*)`\]/g.exec(${{ env.LINT_CHANGELOG }}).slice(1);
                # let lint_name_upper = lint_name.toString().toUpperCase();
                  # let res = await github.rest.search.code({
                      # q: `${lint_name_upper} repo:rust-lang/rust-clippy`,
                      # per_page: 1,
                      # });
                  # if (res.data.items.length == 0) {
                    # await github.rest.issues.createComment({
                      # owner: ${{ github.repository_owner }},
                      # repo: "rust-clippy",
                      # issue_number: ${{ github.event.number }},
                      # body: "Seems that you are trying to add a new lint!\
            # We are currently in a [feature freeze](https://doc.rust-lang.org/nightly/clippy/development/feature_freeze.html), so we are delaying all lint-adding PRs to August 1st and focusing on bugfixes.\
            # Thanks a lot for your contribution, and sorry for the inconvenience.\
            # With ‚ù§ from the Clippy team!"
                    # });

                    # await github.rest.issues.addLabels({
                      # owner: ${{ github.repository_owner }},
                      # repo: "rust-clippy",
                      # issue_number: ${{ github.event.number }},
                      # labels: ["A-new-lint"],
                    # });

                    # await github.rest.issues.update({
                      # owner: "rust-lang",
                      # repo: "rust-clippy",
                      # issue_number: ${{ github.event.number }},
                      # milestone: 2 // "FEATURE FREEZED" Milestone
                    # });
                  # }
                # }
            # }
          # }


  # We need to have the "conclusion" job also on PR CI, to make it possible
  # to add PRs to a merge queue.
  conclusion_changelog:
    needs: [ changelog ]
    # We need to ensure this job does *not* get skipped if its dependencies fail,
    # because a skipped job is considered a success by GitHub. So we have to
    # overwrite `if:`. We use `!cancelled()` to ensure the job does still not get run
    # when the workflow is canceled manually.
    #
    # ALL THE PREVIOUS JOBS NEED TO BE ADDED TO THE `needs` SECTION OF THIS JOB!
    if: ${{ !cancelled() }}
    runs-on: ubuntu-latest
    steps:
      # Manually check the status of all dependencies. `if: failure()` does not work.
      - name: Conclusion
        run: |
          # Print the dependent jobs to see them in the CI log
          jq -C <<< '${{ toJson(needs) }}'
          # Check if all jobs that we depend on (in the needs array) were successful.
          jq --exit-status 'all(.result == "success")' <<< '${{ toJson(needs) }}'
